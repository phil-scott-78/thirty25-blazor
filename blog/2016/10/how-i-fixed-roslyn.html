<!DOCTYPE html>
<html lang="en"><head><meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="/styles.css">
    <link rel="stylesheet" href="https://esm.sh/@wooorm/starry-night@3/style/both">
    <base href="/thirty25-blazor/">
    <script>
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
    </head>

<body class="antialiased font-sans bg-primary-50 dark:bg-primary-950 transition-colors"><header class="sticky top-0 left-2 w-full backdrop-blur bg-primary-200 dark:bg-primary-900/70 border-b border-primary-900/20 dark:border-primary-50/10 shadow-md dark:shadow-lg py-2 md:py-4 z-50"><nav class="mx-auto max-w-5xl px-4 md:px-8 xl:px-0 flex  items-center"><img src="/Content/Blog/media/avatar.svg" alt="Avatar image" class="inline-block h-10 w-10 md:h-12 md:w-12 mr-4  rounded-full shadow-md bg-gradient-to-br from-accent-800 to-accent-500 dark:from-accent-500 dark:to-accent-300">
        <h1><a class="font-extrabold text-2xl md:text-4xl text-primary-700 dark:text-primary-300" href="/">Thirty25</a></h1>
        <div class="ml-auto flex items-center"><button aria-label="Toggle Dark Mode" class="mr-6 dark:text-yellow-300 stroke-1 opacity-80" onclick="swapTheme()"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path></svg></button>
            <a class="text-primary-600 hover:text-primary-300 transition-all hover:scale-105" title="Blog source" href="https://github.com/phil-scott-78/thirty25-statiq"><svg width="2rem" height="2rem" class="fill-current" viewBox="0 0 1024 1024" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8C0 11.54 2.29 14.53 5.47 15.59C5.87 15.66 6.02 15.42 6.02 15.21C6.02 15.02 6.01 14.39 6.01 13.72C4 14.09 3.48 13.23 3.32 12.78C3.23 12.55 2.84 11.84 2.5 11.65C2.22 11.5 1.82 11.13 2.49 11.12C3.12 11.11 3.57 11.7 3.72 11.94C4.44 13.15 5.59 12.81 6.05 12.6C6.12 12.08 6.33 11.73 6.56 11.53C4.78 11.33 2.92 10.64 2.92 7.58C2.92 6.71 3.23 5.99 3.74 5.43C3.66 5.23 3.38 4.41 3.82 3.31C3.82 3.31 4.49 3.1 6.02 4.13C6.66 3.95 7.34 3.86 8.02 3.86C8.7 3.86 9.38 3.95 10.02 4.13C11.55 3.09 12.22 3.31 12.22 3.31C12.66 4.41 12.38 5.23 12.3 5.43C12.81 5.99 13.12 6.7 13.12 7.58C13.12 10.65 11.25 11.33 9.47 11.53C9.76 11.78 10.01 12.26 10.01 13.01C10.01 14.08 10 14.94 10 15.21C10 15.42 10.15 15.67 10.55 15.59C13.71 14.53 16 11.53 16 8C16 3.58 12.42 0 8 0Z" transform="scale(64)"></path></svg></a></div></nav></header>

        <main class="mx-auto max-w-5xl px-4 md:px-8 xl:px-0 mt-4 mb-4 md:mb-16"><article><div class="xl:divide-y  xl:divide-primary-700"><header class="pt-6 xl:pb-6"><div class="space-y-1 text-center"><dl class="space-y-10"><div><dt class="sr-only">Published on</dt>
                        <dd class="text-base font-medium leading-6 text-primary-400"><time datetime="2016-10-31T00:00:00.000">October 31, 2016</time></dd></div></dl>
                <div class="prose prose-stone dark:prose-invert mx-auto"><h1 class>How I Fixed Roslyn</h1></div></div></header>
        <div class="grid-rows-[auto_1fr] divide-y  pb-8 divide-primary-700 xl:grid xl:grid-cols-4 xl:gap-x-6 xl:divide-y-0"><div class="divide-y  divide-primary-700 xl:col-span-3 xl:row-span-2 xl:pb-0"><div class="prose prose-stone dark:prose-invert mt-8 prose-sm md:prose-base lg:prose-lg max-w-full dark:font-light lg:leading-loose"><p>With VS 15 approaching a RC I felt it was time to give it a test run on some of our production code. Visual Studio
itself worked great, butI ran into some interesting issues while executing some of our unit tests. Everything was
compiling fine, but on a handful of tests I'd get the following runtime error</p>
<pre><code class="language-text">Unhandled Exception: System.ArgumentException: Expression of type 'System.Int32' cannot be used for return type 'System.Nullable`1[System.Int32]'
   at System.Linq.Expressions.Expression.ValidateLambdaArgs(Type delegateType, Expression&amp; body, ReadOnlyCollection`1 parameters)
   at System.Linq.Expressions.Expression.Lambda[TDelegate](Expression body, String name, Boolean tailCall, IEnumerable`1 parameters)
   at System.Linq.Expressions.Expression.Lambda[TDelegate](Expression body, Boolean tailCall, IEnumerable`1 parameters)
   at System.Linq.Expressions.Expression.Lambda[TDelegate](Expression body, ParameterExpression[] parameters)
   at ....
</code></pre>
<p>At first I didn't know what to make of it. Frustratingly enough the majority of the code that failing was either a
relatively complicated join statements in EntityFramework, or part of a complex validation rule that we set up with
FluentValidation. I could easily resolve the issue by with an explicit cast or even moving the expression to an
explicitly defined variable. But that would only fix the code I knew I had unit tests around, and we are far from 100%
code coverage. So I wanted to get to the heart of the issue.</p>
<p>Step one was trying to figure out how to reproduce it, but without code using a third party library. The
FluentValidation code was tightly wound to the external library so it was right out, but the EF queries I felt were a
good start. I could maybe just mimic the join that was failing using a couple of <code>List&lt;&gt;</code> and be good to go. I knew it
had to do with casting a nullable int to a regular int, so I took one of the failing queries and simplified it to the
point it still gave the error when running. Once I had that I replaced the <code>DbSet</code> with <code>List&lt;&gt;</code> and arrived with this:</p>
<pre><code class="language-csharp">class Program
{
    static void Main(string[] args)
    {
        var invoices = new List&lt;Invoice&gt; { new Invoice { InvoiceId = 0 } };
        var oneTimeCharges = new List&lt;OneTimeCharge&gt; { new OneTimeCharge { Invoice = 0, OneTimeChargeId = 0 } };
        var otcCharges = invoices.Join(oneTimeCharges, inv =&gt; inv.InvoiceId, otc =&gt; otc.Invoice, (inv, otc) =&gt; inv.InvoiceId);
        Console.WriteLine(otcCharges.Count());
    }
}

public class OneTimeCharge
{
    public int OneTimeChargeId { get; set; }
    public int? Invoice { get; set; }
}

public class Invoice
{
    public int InvoiceId { get; set; }
}
</code></pre>
<p>Threw this into a console application, hit run aaaand....it worked. No error. I had already reproduced the issue using
FluentValidation so I knew the error could be triggered from this console app. Stumped for now I took the dog for a walk
and some fresh air. While walking I started thinking that the compiler shouldn't care about EF, but rather maybe the
collections being of type <code>IQueryable&lt;&gt;</code> was causing the lambdas to be compiled differently. I headed back inside and
threw an <code>AsQueryable()</code> onto the end of both definitions and hit run and....jackpot. Got the failure message, and I was
never happier to see some code fail.</p>
<p>Elated that I had a reproducible issue I naturally wanted to verify why it was happening. Luckily there's a great little
tool at <a href="http://tryroslyn.azurewebsites.net/">http://tryroslyn.azurewebsites.net/</a>. This site lets you view the compiled output of a C# app in a variety of
different Roslyn packages. So copied and paste my little app here, and checked out the code that was generated. I
compared both the version in VS 15 (master) and the current nuget release.</p>
<p>Armed with this I found the code at fault. In the current version the following code is produced:</p>
<pre><code class="language-csharp">Expression&lt;Func&lt;Invoice, int?&gt;&gt; arg_EE_2 = Expression.Lambda&lt;Func&lt;Invoice, int?&gt;&gt;(Expression.Convert(Expression.Property(parameterExpression, methodof(Invoice.get_InvoiceId())), typeof(int?)), new ParameterExpression[]
{
    parameterExpression
});
</code></pre>
<p>In the version in VS 15 (master) this code is produced:</p>
<pre><code class="language-csharp">Expression&lt;Func&lt;Invoice, int?&gt;&gt; arg_DF_2 = Expression.Lambda&lt;Func&lt;Invoice, int?&gt;&gt;(Expression.Property(parameterExpression, methodof(Invoice.get_InvoiceId())), new ParameterExpression[]
{
    parameterExpression
});
</code></pre>
<p>Note the missing <code>Expression.Convert</code>. Feeling good about myself for finding a reproducible test case I headed over to
Roslyn's Github repository to <a href="https://github.com/dotnet/roslyn/issues/14722">file my bug</a>.</p>
<p>A few days passed, and with my wife working night shifts I got the itch to see if I couldn't fix this myself. Heck, I
got a C+ in compiler construction in college - I surely could do this.</p>
<p>Step one was getting Roslyn up and running locally. This was easy enough, I just followed the instructions on the
<a href="https://github.com/dotnet/roslyn/wiki/Building%20Testing%20and%20Debugging">Building Testing and Debugging </a> page. I
walked through the instructions here to get the code building, and just to verify I did it right I ran the unit test
suite. 10 minutes later...success. But oomph that was a brutal wait. My current strategy of a guess and check bug fix
would be a long road to hoe if I didn't come up with a better plan.</p>
<p>Still, I now had the code running locally. So now I could get to work. It was time to try and track down precisely when
things broke. Hopefully with that information I could see what changed and figure out how to get it back to a working
state. A quick look at the difference between what's in VS 2015 Update 3 and VS15 unfortunately provide slightly
overwhelming.</p>
<p><img src="/Content/Blog/media/commits.png" alt="3,700 commits" /></p>
<p>But I did have a powerful thing at my disposal. My reproducible test case was an actual program. I can automate this.
Git has a nice tool called <a href="https://git-scm.com/docs/git-bisect"><code>bisect</code></a> just for this. TLDR of <code>git bisect</code> if you
haven't used it - you give it a starting and ending spot of what you consider good and bad commits plus a command to run
that returns an error code of 0 or 1 depending on if it passes. It then runs a binary search through the commits
executing the command and moving on. I'd compile roslyn on each pass, then use that version of the compiler to compile
my test case application, run it and check the error code returned. Thanks to the binary search of the bisect command
instead of 3,700 commits I'd only need like 12 or 13 runs. Nice!</p>
<p>This did involve some trial and error. It seems the output location of <code>csc.exe</code> changed as part of the changes since
Update3. No problem, nothing a little batch file <code>if</code> statement couldn't resolve. <code>Git bisect</code> also wasn't a huge fan of
the project.json files being modified in the build process so I also made sure to reset things before running my app so
bisect could do its thing cleanly. My script ultimately ended up looking like this:</p>
<pre><code class="language-bash">call Restore.cmd
msbuild /v:m /m /p:Configuration=Release Roslyn.sln

IF EXIST Binaries\Release\Exes\csc\csc.exe (
Binaries\Release\Exes\csc\csc.exe expression.cs
) ELSE (
Binaries\Release\csc.exe expression.cs
)

git reset --hard
expression.exe
</code></pre>
<p>Expression.cs was my source and expression.exe was the compiled app. Time to launch the bisect. To do this I ran the
following commands while in the master branch, which was current failing</p>
<pre><code class="language-bash">git checkout master
git bisect start
git bisect bad
git bisect good update3
git bisect run doit.cmd
</code></pre>
<p>I went to go refresh my drink and walk the dog. Ten minutes later I returned to the following message</p>
<pre><code class="language-text">
6c9e18649f576bd9df1e0db8ad21bfbce0454704 is the first bad commit
commit 6c9e18649f576bd9df1e0db8ad21bfbce0454704
Author: Charles Stoner &lt;chucks@microsoft.com&gt;
Date:   Tue Jul 12 13:51:14 2016 -0700

    Support async methods returning Task-like types

    [Based on features/async-return with tests ported from that branch.]

:040000 040000 5be0af3e25b7c68022d128a9adf5984e2eb03df3 d4ffb41d83a385fda5a1d60e04d488cf081d1a2f M      src
bisect run success
</code></pre>
<p>Fantastic. Looks like I found the guilty commit. Hopefully I could open this up and spot whatever changed relatively
quickly. Unfortunately, well, this was a huge commit.</p>
<p><img src="/Content/Blog/media/huge-commit.png" alt="Lots of changes" /></p>
<p>Sigh. Lots of code to read, but it looked like quite a bit of it was unit tests. Knowing I was dealing with a lambda
issue there was one thing to do at this point - <code>CTRL-F</code> and search for lambda in the
<a href="https://github.com/dotnet/roslyn/commit/6c9e18649f576bd9df1e0db8ad21bfbce0454704">commit on github</a>. Eye balling the
highlighted results showed a couple of hot spots with <code>lambda</code> appearing frequently so I quickly scrolled there.</p>
<p><img src="/Content/Blog/media/lambda-assert.png" alt="Is that a debug.assert" /></p>
<p>That looks like somewhere to start! But I needed a better way to test than hitting the command line and compiling over
and over again. I needed a unit test. I found a file named
<a href="https://github.com/dotnet/roslyn/blob/master/src/Compilers/CSharp/Test/Emit/CodeGen/CodeGenExprLambdaTests.cs">CodeGenExprLambdaTests</a>
and figured this was as good as place as any to write my test. Opening this up I discovered a suite of tests that were
verifying compiler output and executing the results. Perfect! All I had to do was mimic their style and hopefully I
would be in business. Even better I noticed ReSharper picked up the tests so just maybe I could use ReSharper to only
run the test I was working on. In retrospect I probably should have started here, but oh well.</p>
<p>Thanks to a little copy and paste development from one of the existing tests I was able they have a nice way to run the
application and verify the output is correct. Very cool.</p>
<pre><code class="language-csharp">[Fact]
public void ConversionAppliedInLambdaForNonMatchingTypes()
{
    var program = @&quot;
using System;
using System.Collections.Generic;
using System.Linq;
namespace ConsoleApplication2
{
    class Program
    {
        static void Main(string[] args)
        {
            var invoices = new List&lt;Invoice&gt;().AsQueryable();
            var oneTimeCharges = new List&lt;OneTimeCharge&gt;().AsQueryable();
            var otcCharges = invoices.Join(oneTimeCharges, inv =&gt; inv.InvoiceId, otc =&gt; otc.Invoice, (inv, otc) =&gt; inv.InvoiceId);
            Console.Write('k');
        }
    }

    public class OneTimeCharge
    {
        public int OneTimeChargeId { get; set; }
        public int? Invoice { get; set; }
    }
    public class Invoice
    {
        public int InvoiceId { get; set; }
    }
}
&quot;;

    CompileAndVerify(
        sources: new string[] { program, ExpressionTestLibrary },
        additionalRefs: new[] { ExpressionAssemblyRef },
        expectedOutput: @&quot;k&quot;)
        .VerifyDiagnostics();
}
</code></pre>
<p>I ran the unit test using R# with optimism, and instead of seeing an exception about casting I actually hit the
<code>Debug.Assert</code> I suspected. Nice!</p>
<pre><code class="language-text">---------------------------
Assertion Failed: Abort=Quit, Retry=Debug, Ignore=Continue
---------------------------
   at Microsoft.CodeAnalysis.CSharp.UnboundLambdaState.ReallyBind(NamedTypeSymbol delegateType) in C:\Projects\phil-roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs:line 433
   at Microsoft.CodeAnalysis.CSharp.UnboundLambdaState.Bind(NamedTypeSymbol delegateType) in C:\Projects\phil-roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs:line 345
   at Microsoft.CodeAnalysis.CSharp.UnboundLambda.Bind(NamedTypeSymbol delegateType) in C:\Projects\phil-roslyn\src\Compilers\CSharp\Portable\BoundTree\UnboundLambda.cs:line 277
   at Microsoft.CodeAnalysis.CSharp.Binder.CreateAnonymousFunctionConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, Boolean isCast, TypeSymbol destination, DiagnosticBag diagnostics) in C:\Projects\phil-roslyn\src\Compilers\CSharp\Portable\Binder\Binder_Conversions.cs:line 300
   at Microsoft.CodeAnalysis.CSharp.Binder.CreateConversion(SyntaxNode syntax, BoundExpression source, Conversion conversion, Boolean isCast, Boolean wasCompi......

&lt;truncated&gt;
---------------------------
Abort   Retry   Ignore
---------------------------
</code></pre>
<p>That line of code matched exactly where I suspected from my quick code review. Just to confirm that my test would work
in the happy path, I quickly edited my unit test to a passing version without <code>AsQueryable</code> and ran it. Success! Good
news all around. Not only does the unit test runner work, but I had a great starting spot for what is going wrong.</p>
<p>The line of code in question that was failing was this section of code.</p>
<pre><code class="language-csharp">if (_returnInferenceCache.TryGetValue(cacheKey, out returnInferenceLambda) &amp;&amp; returnInferenceLambda.InferredFromSingleType)
{
    lambdaSymbol = returnInferenceLambda.Symbol;
    Debug.Assert(lambdaSymbol.ReturnType == returnType);
    Debug.Assert(lambdaSymbol.RefKind == refKind);

    lambdaBodyBinder = returnInferenceLambda.Binder;
    block = returnInferenceLambda.Body;
    diagnostics.AddRange(returnInferenceLambda.Diagnostics);

    goto haveLambdaBodyAndBinders;
}

</code></pre>
<p>Right there is the <code>Debug.Assert</code> failing when ReturnType doesn't equal whatever this <code>lamdaSymbol.ReturnType</code> is. Huh.
So it looks like they are caching previously generated expressions if they match, but it appears we are somehow pulling
one out that doesn't have a matching return type. Running the test through the debugger everything else seemed to jive,
just not this. This makes sense - in the release version the <code>Debug.Assert</code> wouldn't be there, but rather it would keep
moving forward and return the expression body for a lambda that was close but didn't have the right return type. That's
why I was only seeing it on complex joins and the such - I needed one statements where I had a similar lambda that
returned an int, and the same lambda with a slightly different return type. Subtle.</p>
<p>Now to fix. Looking at the end of the if statement I saw there was a check for <code>InferredFromSingleType</code> so I suspected
maybe just more filtering was needed on the cache. So I added one more check</p>
<pre><code class="language-csharp">if (_returnInferenceCache.TryGetValue(cacheKey, out returnInferenceLambda) &amp;&amp; returnInferenceLambda.InferredFromSingleType &amp;&amp; returnInferenceLambda.Symbol.ReturnType == returnType)
...
</code></pre>
<p>Reran my test and...success! Happy days.</p>
<p>Armed with a reproducible unit test and a fix I mustered up the courage to
<a href="https://github.com/dotnet/roslyn/pull/14755">submit a PR</a>. After receiving some feedback I was pumped to see it
accepted and merged into the codebase hopefully in time for the VS 15 RC release.</p>
<h2 id="postscript">Postscript</h2>
<p>To be honest, I never felt like I had gotten this implementation correct. It kind of felt like things were either being
put into or pulled out of cache improperly, and I was just filtering those out. And while I felt confident my fix
wouldn't introduce any issues thanks to its relatively local scope, I didn't have enough confidence to go digging in and
changing things related to how things were being compared for that object. I wasn't sure what behavior was really
expected. But a few days later I noticed a new issue pop up sparked by my PR
<a href="https://github.com/dotnet/roslyn/issues/14774">new issue</a> around this. Looks like as I suspected my fix is just a
bandage, and the caching is in fact the true bug. I fully expect this issue's fix will cause my little addition to the
compiler to go away, but that's ok. Hopefully my test will remain to verify the behavior, and even if my tiny bit of
code isn't running in the compiler I'm still pretty happy to be able to contribute to something like Roslyn.</p>
</div>
                <div class="pb-6 pt-6 text-sm text-primary-300"><a target="_blank" rel="noopener noreferrer" href="https://github.com/BlazorStatic/Thirty25.Web/tree/main/Content/Blog/2016/10/how-i-fixed-roslyn">View on GitHub</a></div></div>
            <footer><div class=" text-sm font-medium leading-5 divide-primary-700 xl:col-start-1 xl:row-start-2 xl:divide-y"><div class="py-4 xl:py-8"><h2 class="text-xs uppercase tracking-wide text-primary-400">Tags</h2>
                        <div class="flex flex-wrap"><a class="text-primary-500 hover:text-primary-400 mr-3 text-sm font-medium uppercase" href="tags/roslyn">roslyn</a></div></div></div>
                <div class="pt-4 xl:pt-8"><a class="text-primary-500 hover:text-primary-400" aria-label="Back to the home" href>‚Üê Back to the home</a></div></footer></div></div></article></main>

        <footer></footer>
        <blazor-focus-on-navigate selector="h1"></blazor-focus-on-navigate></body>
<script>
    function swapTheme(){
        if (document.documentElement.classList.contains('dark')) {
            document.documentElement.classList.remove('dark');
            localStorage.theme = 'light';
        } else {
            document.documentElement.classList.add('dark');
            localStorage.theme = 'dark';
        }
    }
</script>

<script type="module">
    import {
        common,
        createStarryNight
    } from 'https://esm.sh/@wooorm/starry-night@3?bundle'
    import {toDom} from 'https://esm.sh/hast-util-to-dom@4?bundle'

    const starryNight = await createStarryNight(common)
    const prefix = 'language-'

    const nodes = Array.from(document.body.querySelectorAll('code'))

    for (const node of nodes) {
        const className = Array.from(node.classList).find(function (d) {
            return d.startsWith(prefix)
        })
        if (!className) continue
        const scope = starryNight.flagToScope(className.slice(prefix.length))
        if (!scope) continue
        const tree = starryNight.highlight(node.textContent, scope)
        node.replaceChildren(toDom(tree, {fragment: true}))
    }
</script></html>